const { readFileSync, accessSync, constants, lstatSync } = require('fs');
const { basename } = require('path');
const { consul } = require('./consul');
const { request } = require('http');

const DEFAULT_OPTIONS = {
  timeout: 10,
  cluster: 'default',
  service: 'toutiao.tos.tosapi'
};

const HEADERS = {
  access: 'x-tos-access',
  md5: 'x-tos-md5',
  reqId: 'x-tos-request-id'
};

class TosClient {
  constructor (options = {}) {
    this.bucket = options.bucket;
    this.accessKey = options.accessKey;
    this.timeout = options.timeout || DEFAULT_OPTIONS.timeout;
    this.cluster = options.cluster || DEFAULT_OPTIONS.cluster;
    this.service = options.service || DEFAULT_OPTIONS.service;
  }

  _checkMust() {
    if (!this.bucket || !this.accessKey) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * 上传文件
   * @param path 文件本地路径
   * @returns {Promise<any>}
   */
  uploadFile(path) {
    let isExist = true, canAccess = true, isFile = true;
    try {
      canAccess = !accessSync(path, constants.R_OK);
      const lstat = lstatSync(path);
      isFile = lstat.isFile();
    } catch (e) {
      isExist = false;
    }
    if (isExist && canAccess && isFile) {
      const name = basename(path);
      const buffer = readFileSync(path);
      return this.uploadFileBuf(name, buffer);
    } else {
      return new Promise((resolve, reject) => {
        if (!isExist) {
          reject(`${path} not exists`);
        } else if (!canAccess) {
          reject(`${path} can not be read`);
        } else if (!isFile) {
          reject(`${path} is not a file`);
        } else {
          reject('read file error');
        }
      });
    }
  }

  /**
   * 上传文件
   * @param name 保存到 TOS 的文件名
   * @param buf 文件 buffer
   * @returns {Promise<any>}
   */
  uploadFileBuf(name, buf) {
    return new Promise((resolve, reject) => {
      if (this._checkMust()) {
        reject('bucket or access_key is null');
      }
      consul(this.cluster, this.service)
        .then(({ host, port }) => {
          const reqOpts = {
            host,
            port,
            path: `/${this.bucket}/${name}`,
            method: 'PUT',
            headers: {
              [HEADERS.access]: this.accessKey,
              'content-length': buf.length
            }
          };
          const req = request(reqOpts, res => {
            const { statusCode } = res;
            if (statusCode !== 200) {
              reject(`tos upload file error: ${statusCode}`);
              res.resume();
              return;
            }
            res.on('data', () => {});
            res.on('end', () => resolve());
          });

          req.on('error', err => reject(err));

          req.write(buf);
          req.end();
        })
        .catch(err => reject(err));
    });
  }

  /**
   * 下载文件
   * @param name
   * @returns {Promise<any>}
   */
  downloadFileBuf(name) {
    return new Promise((resolve, reject) => {
      if (this._checkMust()) {
        reject('bucket or access_key is null');
      }
      consul(this.cluster, this.service)
        .then(({ host, port}) => {
          const reqOpts = {
            host,
            port,
            path: `/${this.bucket}/${name}`,
            method: 'GET',
            headers: {
              [HEADERS.access]: this.accessKey
            }
          };
          const req = request(reqOpts, res => {
            const { statusCode } = res;
            if (statusCode !== 200) {
              reject(`tos download file error: ${statusCode}`);
              res.resume();
              return;
            }

            let buf = Buffer.alloc(0);
            res.on('data', chunk => buf = Buffer.concat([buf, Buffer.from(chunk)]));
            res.on('end', () => resolve(buf));
          });

          req.on('error', err => reject(err));
          req.end();
        })
        .catch(err => reject(err));
    });
  }

  /**
   * 删除文件
   * @param name
   * @returns {Promise<any>}
   */
  deleteFile(name) {
    return new Promise((resolve, reject) => {
      if (this._checkMust()) {
        reject('bucket or access_key is null');
      }
      consul(this.cluster, this.service)
        .then(({ host, port }) => {
          const reqOpts = {
            host,
            port,
            path: `/${this.bucket}/${name}`,
            method: 'DELETE',
            headers: {
              [HEADERS.access]: this.accessKey
            }
          };
          const req = request(reqOpts, res => {
            const { statusCode } = res;
            if (statusCode !== 204) {
              reject(`delete tos file error: ${statusCode}`);
              res.resume();
              return;
            }
            res.on('data', () => {});
            res.on('end', () => resolve());
          });

          req.on('error', err => reject(err));
          req.end();
        })
        .catch(err => reject(err));
    })
  }

  /**
   * 获取文件的大小和最后修改时间
   * @param name
   * @returns {Promise<any>}
   */
  getFileInfo(name) {
    return new Promise((resolve, reject) => {
      if (this._checkMust()) {
        reject('bucket or access_key is null');
      }
      consul(this.cluster, this.service)
        .then(({ host, port }) => {
          const reqOpts = {
            host,
            port,
            path: `/${this.bucket}/${name}`,
            method: 'HEAD',
            headers: {
              [HEADERS.access]: this.accessKey
            }
          };
          const req = request(reqOpts, res => {
            const { statusCode, headers } = res;
            if (statusCode === 404) {
              reject(`${name} 404 not found`);
              res.resume();
              return;
            }

            res.setEncoding('utf8');
            let rawData = '';
            res.on('data', chunk => rawData += chunk);
            res.on('end', () => {
              if (statusCode === 200) {
                const ret = {};
                ret['size'] = headers['content-length'];
                const lastModified = headers['last-modified'];
                ret['time'] = new Date(lastModified).getTime() / 1000;
                resolve(ret);
              } else {
                reject(`error status code: ${statusCode}. ${rawData}`);
              }
            });
          });

          req.on('error', err => reject(err));
          req.end();
        })
        .catch(err => reject(err));
    });
  }
}

module.exports = TosClient;